<HTML
><HEAD
><TITLE
>Basic Statements</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.73
"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.3.3 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="PL/pgSQL - SQL Procedural Language"
HREF="plpgsql.html"><LINK
REL="PREVIOUS"
TITLE="Expressions"
HREF="plpgsql-expressions.html"><LINK
REL="NEXT"
TITLE="Control Structures"
HREF="plpgsql-control-structures.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-05-24T21:33:34"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.3.3 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="plpgsql-expressions.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 19. <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> - <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> Procedural Language</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="plpgsql-control-structures.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PLPGSQL-STATEMENTS"
>19.5. Basic Statements</A
></H1
><P
>    In this section and the following ones, we describe all the statement
    types that are explicitly understood by
    <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>.
    Anything not recognized as one of these statement types is presumed
    to be an SQL query, and is sent to the main database engine to execute
    (after substitution for any <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> variables
    used in the statement).  Thus,
    for example, SQL <TT
CLASS="COMMAND"
>INSERT</TT
>, <TT
CLASS="COMMAND"
>UPDATE</TT
>, and
    <TT
CLASS="COMMAND"
>DELETE</TT
> commands may be considered to be statements of
    <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>.  But they are not specifically
    listed here.
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-STATEMENTS-ASSIGNMENT"
>19.5.1. Assignment</A
></H2
><P
>     An assignment of a value to a variable or row/record field is
     written as:
</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>identifier</I
></TT
> := <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>;</PRE
><P>
     As explained above, the expression in such a statement is evaluated
     by means of an SQL <TT
CLASS="COMMAND"
>SELECT</TT
> command sent to the main
     database engine.  The expression must yield a single value.
    </P
><P
>     If the expression's result data type doesn't match the variable's
     data type, or the variable has a specific size/precision
     (like <TT
CLASS="TYPE"
>char(20)</TT
>), the result value will be implicitly
     converted by the <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> interpreter using
     the result type's output-function and 
     the variable type's input-function. Note that this could potentially
     result in run-time errors generated by the input function, if the
     string form of the result value is not acceptable to the input function.
    </P
><P
>     Examples:
</P><PRE
CLASS="PROGRAMLISTING"
>user_id := 20;
tax := subtotal * 0.06;</PRE
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-SELECT-INTO"
>19.5.2. SELECT INTO</A
></H2
><P
>     The result of a SELECT command yielding multiple columns (but
     only one row) can be assigned to a record variable, row-type
     variable, or list of scalar variables.  This is done by:

</P><PRE
CLASS="SYNOPSIS"
>SELECT INTO <TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>expressions</I
></TT
> FROM ...;</PRE
><P>

     where <TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
> can be a record variable, a row
     variable, or a comma-separated list of simple variables and
     record/row fields. Note that this is quite different from
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>'s normal interpretation of SELECT INTO, which is that the
     INTO target is a newly created table.  (If you want to create a
     table from a SELECT result inside a <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> function, use the
     syntax <TT
CLASS="COMMAND"
>CREATE TABLE ... AS SELECT</TT
>.)
    </P
><P
>     If a row or a variable list is used as target, the selected values
     must exactly match the structure of the target(s), or a run-time error
     occurs.  When a record variable is the target, it automatically
     configures itself to the row type of the query result columns.
    </P
><P
>     Except for the INTO clause, the SELECT statement is the same as a normal
     SQL SELECT query and can use the full power of SELECT.
    </P
><P
>     If the SELECT query returns zero rows, null values are assigned to the
     target(s).  If the SELECT query returns multiple rows, the first
     row is assigned to the target(s) and the rest are discarded.
     (Note that <SPAN
CLASS="QUOTE"
>"the first row"</SPAN
> is not well-defined unless you've
     used ORDER BY.)
    </P
><P
>     At present, the INTO clause can appear almost anywhere in the SELECT
     query, but it is recommended to place it immediately after the SELECT
     keyword as depicted above.  Future versions of
     <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> may be less forgiving about
     placement of the INTO clause.
    </P
><P
>     You can use <TT
CLASS="LITERAL"
>FOUND</TT
> immediately after a SELECT
     INTO statement to determine whether the assignment was successful
     (that is, at least one row was was returned by the SELECT
     statement). For example:
  
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT INTO myrec * FROM EMP WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION ''employee % not found'', myname;
END IF;</PRE
><P>

     Alternatively, you can use the <TT
CLASS="LITERAL"
>IS NULL</TT
> (or <TT
CLASS="LITERAL"
>ISNULL</TT
>) conditional to
     test for whether a RECORD/ROW result is null.  Note that there is no
     way to tell whether any additional rows might have been discarded.
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>DECLARE
    users_rec RECORD;
    full_name varchar;
BEGIN
    SELECT INTO users_rec * FROM users WHERE user_id=3;

    IF users_rec.homepage IS NULL THEN
        -- user entered no homepage, return "http://"

        RETURN ''http://'';
    END IF;
END;</PRE
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-STATEMENTS-PERFORM"
>19.5.3. Executing an expression or query with no result</A
></H2
><P
>     Sometimes one wishes to evaluate an expression or query but discard
     the result (typically because one is calling a function that has
     useful side-effects but no useful result value).  To do this in
     <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>, use the PERFORM statement:

</P><PRE
CLASS="SYNOPSIS"
>PERFORM <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>;</PRE
><P>

     This executes a <TT
CLASS="COMMAND"
>SELECT</TT
>
     <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
> and discards the
     result. <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> variables are
     substituted in the query as usual.  Also, the special variable
     <TT
CLASS="LITERAL"
>FOUND</TT
> is set to true if the query produced at
     least one row, or false if it produced no rows.
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     One might expect that SELECT with no INTO clause would accomplish
     this result, but at present the only accepted way to do it is PERFORM.
    </P
></BLOCKQUOTE
></DIV
><P
>     An example:
</P><PRE
CLASS="PROGRAMLISTING"
>PERFORM create_mv(''cs_session_page_requests_mv'', my_query);</PRE
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-STATEMENTS-EXECUTING-DYN-QUERIES"
>19.5.4. Executing dynamic queries</A
></H2
><P
>     Oftentimes you will want to generate dynamic queries inside
     your <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> functions, that is,
     queries that will involve different tables or different data types
     each time they are executed.  <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>'s
     normal attempts to cache plans for queries will not work in such
     scenarios.  To handle this sort of problem, the EXECUTE statement
     is provided:

</P><PRE
CLASS="SYNOPSIS"
>EXECUTE <TT
CLASS="REPLACEABLE"
><I
>query-string</I
></TT
>;</PRE
><P>

     where <TT
CLASS="REPLACEABLE"
><I
>query-string</I
></TT
> is an expression
     yielding a string (of type
     <TT
CLASS="TYPE"
>text</TT
>) containing the <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>
     to be executed.  This string is fed literally to the SQL engine.
    </P
><P
>     Note in particular that no substitution of <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>
     variables is done on the query string.  The values of variables must
     be inserted in the query string as it is constructed.
    </P
><P
>    When working with dynamic queries you will have to face
    escaping of single quotes in <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>. Please refer to the
    table in <A
HREF="plpgsql-porting.html"
>Section 19.11</A
>
    for a detailed explanation that will save you some effort.
    </P
><P
>     Unlike all other queries in <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>, a
     <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
> run by an EXECUTE statement is
     not prepared and saved just once during the life of the server.
     Instead, the <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
> is prepared each
     time the statement is run. The
     <TT
CLASS="REPLACEABLE"
><I
>query-string</I
></TT
> can be dynamically
     created within the procedure to perform actions on variable
     tables and fields.
    </P
><P
>     The results from SELECT queries are discarded by EXECUTE, and
     SELECT INTO is not currently supported within EXECUTE.  So, the
     only way to extract a result from a dynamically-created SELECT is
     to use the FOR-IN-EXECUTE form described later.
    </P
><P
>     An example:
<DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN35873"
></A
><P
></P
><PRE
CLASS="PROGRAMLISTING"
>EXECUTE ''UPDATE tbl SET ''
        || quote_ident(fieldname)
        || '' = ''
        || quote_literal(newvalue)
        || '' WHERE ...'';</PRE
><P
></P
></DIV
>
    </P
><P
>     This example shows use of the functions
     <TT
CLASS="FUNCTION"
>quote_ident</TT
>(<TT
CLASS="TYPE"
>TEXT</TT
>) and
     <TT
CLASS="FUNCTION"
>quote_literal</TT
>(<TT
CLASS="TYPE"
>TEXT</TT
>).
     Variables containing field and table identifiers should be
     passed to function <TT
CLASS="FUNCTION"
>quote_ident()</TT
>.
     Variables containing literal elements of the dynamic query
     string should be passed to
     <TT
CLASS="FUNCTION"
>quote_literal()</TT
>.  Both take the
     appropriate steps to return the input text enclosed in single
     or double quotes and with any embedded special characters
     properly escaped.
    </P
><P
>     Here is a much larger example of a dynamic query and EXECUTE:
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION cs_update_referrer_type_proc() RETURNS INTEGER AS '
DECLARE
    referrer_keys RECORD;  -- Declare a generic record to be used in a FOR
    a_output varchar(4000);
BEGIN 
    a_output := ''CREATE FUNCTION cs_find_referrer_type(varchar,varchar,varchar) 
                  RETURNS VARCHAR AS '''' 
                     DECLARE 
                         v_host ALIAS FOR $1; 
                         v_domain ALIAS FOR $2; 
                         v_url ALIAS FOR $3;
                     BEGIN ''; 

    -- 
    -- Notice how we scan through the results of a query in a FOR loop
    -- using the FOR &lt;record&gt; construct.
    --

    FOR referrer_keys IN SELECT * FROM cs_referrer_keys ORDER BY try_order LOOP
        a_output := a_output || '' IF v_'' || referrer_keys.kind || '' LIKE '''''''''' 
                 || referrer_keys.key_string || '''''''''' THEN RETURN '''''' 
                 || referrer_keys.referrer_type || ''''''; END IF;''; 
    END LOOP; 
  
    a_output := a_output || '' RETURN NULL; END; '''' LANGUAGE ''''plpgsql'''';''; 
 
    -- This works because we are not substituting any variables
    -- Otherwise it would fail. Look at PERFORM for another way to run functions
    
    EXECUTE a_output; 
END; 
' LANGUAGE 'plpgsql';</PRE
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-STATEMENTS-DIAGNOSTICS"
>19.5.5. Obtaining result status</A
></H2
><P
>	 There are several ways to determine the effect of a command. The
	 first method is to use the <TT
CLASS="LITERAL"
>GET DIAGNOSTICS</TT
>,
	 which has the form:

</P><PRE
CLASS="SYNOPSIS"
>GET DIAGNOSTICS <TT
CLASS="REPLACEABLE"
><I
>variable</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>item</I
></TT
> [<SPAN
CLASS="OPTIONAL"
> , ... </SPAN
>] ;</PRE
><P>

     This command allows retrieval of system status indicators.  Each
     <TT
CLASS="REPLACEABLE"
><I
>item</I
></TT
> is a keyword identifying a state
     value to be assigned to the specified variable (which should be
     of the right data type to receive it).  The currently available
     status items are <TT
CLASS="VARNAME"
>ROW_COUNT</TT
>, the number of rows
     processed by the last <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> query sent down to
     the <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> engine; and <TT
CLASS="VARNAME"
>RESULT_OID</TT
>,
     the OID of the last row inserted by the most recent
     <SPAN
CLASS="ACRONYM"
>SQL</SPAN
> query.  Note that <TT
CLASS="VARNAME"
>RESULT_OID</TT
>
     is only useful after an INSERT query.
    </P
><P
><DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN35900"
></A
><P
></P
><PRE
CLASS="PROGRAMLISTING"
>      GET DIAGNOSTICS var_integer = ROW_COUNT;</PRE
><P
></P
></DIV
>
    </P
><P
>     There is a special variable named <TT
CLASS="LITERAL"
>FOUND</TT
> of
     type <TT
CLASS="TYPE"
>boolean</TT
>.  <TT
CLASS="LITERAL"
>FOUND</TT
> starts out
     false within each <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> function.
     It is set by each of the following types of statements:
	 <P
></P
></P><UL
><LI
><P
>		A SELECT INTO statement sets <TT
CLASS="LITERAL"
>FOUND</TT
>
		true if it returns a row, false if no row is returned.
	   </P
></LI
><LI
><P
>		A PERFORM statement sets <TT
CLASS="LITERAL"
>FOUND</TT
>
		true if it produces (discards) a row, false if no row is
		produced.
	   </P
></LI
><LI
><P
>		UPDATE, INSERT, and DELETE statements set
		<TT
CLASS="LITERAL"
>FOUND</TT
> true if at least one row is
		affected, false if no row is affected.
	   </P
></LI
><LI
><P
>		A FETCH statement sets <TT
CLASS="LITERAL"
>FOUND</TT
>
		true if it returns a row, false if no row is returned.
	   </P
></LI
><LI
><P
>		A FOR statement sets <TT
CLASS="LITERAL"
>FOUND</TT
>
		true if it iterates one or more times, else false.
		This applies to all three variants of the FOR statement
		(integer FOR loops, record-set FOR loops, and dynamic
		record-set FOR loops). <TT
CLASS="LITERAL"
>FOUND</TT
> is only set
		when the FOR loop exits: inside the execution of the loop,
		<TT
CLASS="LITERAL"
>FOUND</TT
> is not modified by the FOR statement,
		although it may be changed by the execution of other
		statements within the loop body.
	   </P
></LI
></UL
><P>
     <TT
CLASS="LITERAL"
>FOUND</TT
> is a local variable; any changes
     to it affect only the current <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>
     function.
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="plpgsql-expressions.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="plpgsql-control-structures.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Expressions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="plpgsql.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Control Structures</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>