<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<title>47.3. Index Scanning</title>
<link rel="stylesheet" href="stylesheet.css" type="text/css">
<link rev="made" href="pgsql-docs@postgresql.org">
<meta name="generator" content="DocBook XSL Stylesheets V1.64.1">
<link rel="home" href="index.html" title="PostgreSQL 8.1devel Documentation">
<link rel="up" href="indexam.html" title="Chapter 47. Index Access Method Interface Definition">
<link rel="previous" href="index-functions.html" title="47.2. Index Access Method Functions">
<link rel="next" href="index-locking.html" title="47.4. Index Locking Considerations">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="sect1" lang="en">
<div class="titlepage">
<div><div><h2 class="title" style="clear: both">
<a name="index-scanning"></a>47.3. Index Scanning</h2></div></div>
<div></div>
</div>
<p>   In an index scan, the index access method is responsible for regurgitating
   the TIDs of all the tuples it has been told about that match the
   <i class="firstterm">scan keys</i>.  The access method is <span class="emphasis"><em>not</em></span> involved in
   actually fetching those tuples from the index's parent table, nor in
   determining whether they pass the scan's time qualification test or other
   conditions.
  </p>
<p>   A scan key is the internal representation of a <tt class="literal">WHERE</tt> clause of
   the form <i class="replaceable"><tt>index_key</tt></i> <i class="replaceable"><tt>operator</tt></i>
   <i class="replaceable"><tt>constant</tt></i>, where the index key is one of the columns of the
   index and the operator is one of the members of the operator class
   associated with that index column.  An index scan has zero or more scan
   keys, which are implicitly ANDed [mdash ] the returned tuples are expected
   to satisfy all the indicated conditions.
  </p>
<p>   The operator class may indicate that the index is <i class="firstterm">lossy</i> for a
   particular operator; this implies that the index scan will return all the
   entries that pass the scan key, plus possibly additional entries that do
   not.  The core system's indexscan machinery will then apply that operator
   again to the heap tuple to verify whether or not it really should be
   selected.  For non-lossy operators, the index scan must return exactly the
   set of matching entries, as there is no recheck.
  </p>
<p>   Note that it is entirely up to the access method to ensure that it
   correctly finds all and only the entries passing all the given scan keys.
   Also, the core system will simply hand off all the <tt class="literal">WHERE</tt>
   clauses that match the index keys and operator classes, without any
   semantic analysis to determine whether they are redundant or
   contradictory.  As an example, given
   <tt class="literal">WHERE x &gt; 4 AND x &gt; 14</tt> where <tt class="literal">x</tt> is a b-tree
   indexed column, it is left to the b-tree <tt class="function">amrescan</tt> function
   to realize that the first scan key is redundant and can be discarded.
   The extent of preprocessing needed during <tt class="function">amrescan</tt> will
   depend on the extent to which the index access method needs to reduce
   the scan keys to a &#8220;<span class="quote">normalized</span>&#8221; form.
  </p>
<p>   The <tt class="function">amgettuple</tt> function has a <tt class="literal">direction</tt> argument,
   which can be either <tt class="literal">ForwardScanDirection</tt> (the normal case)
   or  <tt class="literal">BackwardScanDirection</tt>.  If the first call after
   <tt class="function">amrescan</tt> specifies <tt class="literal">BackwardScanDirection</tt>, then the
   set of matching index entries is to be scanned back-to-front rather than in
   the normal front-to-back direction, so <tt class="function">amgettuple</tt> must return
   the last matching tuple in the index, rather than the first one as it
   normally would.  (This will only occur for access
   methods that advertise they support ordered scans by setting
   <tt class="structname">pg_am</tt>.<tt class="structfield">amorderstrategy</tt> nonzero.)  After the
   first call, <tt class="function">amgettuple</tt> must be prepared to advance the scan in
   either direction from the most recently returned entry.
  </p>
<p>   The access method must support &#8220;<span class="quote">marking</span>&#8221; a position in a scan
   and later returning to the marked position.  The same position may be
   restored multiple times.  However, only one position need be remembered
   per scan; a new <tt class="function">ammarkpos</tt> call overrides the previously
   marked position.
  </p>
<p>   Both the scan position and the mark position (if any) must be maintained
   consistently in the face of concurrent insertions or deletions in the
   index.  It is OK if a freshly-inserted entry is not returned by a scan that
   would have found the entry if it had existed when the scan started, or for
   the scan to return such an entry upon rescanning or backing
   up even though it had not been returned the first time through.  Similarly,
   a concurrent delete may or may not be reflected in the results of a scan.
   What is important is that insertions or deletions not cause the scan to
   miss or multiply return entries that were not themselves being inserted or
   deleted.  (For an index type that does not set
   <tt class="structname">pg_am</tt>.<tt class="structfield">amconcurrent</tt>, it is sufficient to
   handle these cases for insertions or deletions performed by the same
   backend that's doing the scan.  But when <tt class="structfield">amconcurrent</tt> is
   true, insertions or deletions from other backends must be handled as well.)
  </p>
</div></body>
</html>
