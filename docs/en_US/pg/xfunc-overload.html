<HTML
><HEAD
><TITLE
>Function Overloading</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.73
"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.3.3 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Extending SQL: Functions"
HREF="xfunc.html"><LINK
REL="PREVIOUS"
TITLE="C Language Functions"
HREF="xfunc-c.html"><LINK
REL="NEXT"
TITLE="Table Functions"
HREF="xfunc-tablefunctions.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-05-24T21:33:34"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.3.3 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="xfunc-c.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 9. Extending <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>: Functions</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="xfunc-tablefunctions.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XFUNC-OVERLOAD"
>9.6. Function Overloading</A
></H1
><A
NAME="AEN32273"
></A
><P
>    More than one function may be defined with the same SQL name, so long
    as the arguments they take are different.  In other words,
    function names can be <I
CLASS="FIRSTTERM"
>overloaded</I
>.  When a
    query is executed, the server will determine which function to
    call from the data types and the number of the provided arguments.
    Overloading can also be used to simulate functions with a variable
    number of arguments, up to a finite maximum number.
   </P
><P
>    A function may also have the same name as an attribute.  In the case
    that there is an ambiguity between a function on a complex type and
    an attribute of the complex type, the attribute will always be used.
   </P
><P
>    When creating a family of overloaded functions, one should be
    careful not to create ambiguities.  For instance, given the
    functions
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION test(int, real) RETURNS ...
CREATE FUNCTION test(smallint, double precision) RETURNS ...</PRE
><P>
    it is not immediately clear which function would be called with
    some trivial input like <TT
CLASS="LITERAL"
>test(1, 1.5)</TT
>.  The
    currently implemented resolution rules are described in the
    <I
CLASS="CITETITLE"
>User's Guide</I
>, but it is unwise to design a
    system that subtly relies on this behavior.
   </P
><P
>    When overloading C language functions, there is an additional
    constraint: The C name of each function in the family of
    overloaded functions must be different from the C names of all
    other functions, either internal or dynamically loaded.  If this
    rule is violated, the behavior is not portable.  You might get a
    run-time linker error, or one of the functions will get called
    (usually the internal one).  The alternative form of the
    <TT
CLASS="LITERAL"
>AS</TT
> clause for the SQL <TT
CLASS="COMMAND"
>CREATE
    FUNCTION</TT
> command decouples the SQL function name from
    the function name in the C source code.  E.g.,
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION test(int) RETURNS int
    AS '<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>', 'test_1arg'
    LANGUAGE C;
CREATE FUNCTION test(int, int) RETURNS int
    AS '<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>', 'test_2arg'
    LANGUAGE C;</PRE
><P>
    The names of the C functions here reflect one of many possible conventions.
   </P
><P
>    Prior to <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.0, this
    alternative syntax did not exist.  There is a trick to get around
    the problem, by defining a set of C functions with different names
    and then define a set of identically-named SQL function wrappers
    that take the appropriate argument types and call the matching C
    function.
   </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xfunc-c.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xfunc-tablefunctions.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>C Language Functions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="xfunc.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Table Functions</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>