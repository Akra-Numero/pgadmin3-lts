<HTML
><HEAD
><TITLE
>The Parser Stage</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.73
"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.3.3 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Overview of PostgreSQL Internals"
HREF="overview.html"><LINK
REL="PREVIOUS"
TITLE="How Connections are Established"
HREF="connect-estab.html"><LINK
REL="NEXT"
TITLE="The PostgreSQL Rule System"
HREF="rule-system.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-05-24T21:33:34"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.3.3 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="connect-estab.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 2. Overview of PostgreSQL Internals</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="rule-system.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PARSER-STAGE"
>2.3. The Parser Stage</A
></H1
><P
>    The <I
CLASS="FIRSTTERM"
>parser stage</I
> consists of two parts:

    <P
></P
></P><UL
><LI
><P
>       The <I
CLASS="FIRSTTERM"
>parser</I
> defined in
       <TT
CLASS="FILENAME"
>gram.y</TT
> and <TT
CLASS="FILENAME"
>scan.l</TT
> is
       built using the Unix tools <SPAN
CLASS="APPLICATION"
>yacc</SPAN
>
       and <SPAN
CLASS="APPLICATION"
>lex</SPAN
>.
      </P
></LI
><LI
><P
>       The <I
CLASS="FIRSTTERM"
>transformation process</I
> does
       modifications and augmentations to the data structures returned by the parser.
      </P
></LI
></UL
><P>
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN52005"
>2.3.1. Parser</A
></H2
><P
>     The parser has to check the query string (which arrives as
     plain ASCII text) for valid syntax. If the syntax is correct a
     <I
CLASS="FIRSTTERM"
>parse tree</I
> is built up and handed back otherwise an error is
     returned. For the implementation the well known Unix
     tools <SPAN
CLASS="APPLICATION"
>lex</SPAN
> and <SPAN
CLASS="APPLICATION"
>yacc</SPAN
>
     are used.
    </P
><P
>     The <I
CLASS="FIRSTTERM"
>lexer</I
> is defined in the file
     <TT
CLASS="FILENAME"
>scan.l</TT
> and is responsible
     for recognizing <I
CLASS="FIRSTTERM"
>identifiers</I
>,
     the <I
CLASS="FIRSTTERM"
>SQL keywords</I
> etc. For
     every keyword or identifier that is found, a <I
CLASS="FIRSTTERM"
>token</I
>
     is generated and handed to the parser.
    </P
><P
>     The parser is defined in the file <TT
CLASS="FILENAME"
>gram.y</TT
> and consists of a
     set of <I
CLASS="FIRSTTERM"
>grammar rules</I
> and <I
CLASS="FIRSTTERM"
>actions</I
>
     that are executed
     whenever a rule is fired. The code of the actions (which
     is actually C-code) is used to build up the parse tree.
    </P
><P
>     The file <TT
CLASS="FILENAME"
>scan.l</TT
> is transformed to
     the C-source file <TT
CLASS="FILENAME"
>scan.c</TT
>
     using the program <SPAN
CLASS="APPLICATION"
>lex</SPAN
>
     and <TT
CLASS="FILENAME"
>gram.y</TT
> is transformed to
     <TT
CLASS="FILENAME"
>gram.c</TT
> using <SPAN
CLASS="APPLICATION"
>yacc</SPAN
>.
     After these transformations have taken
     place a normal C-compiler can be used to create the
     parser. Never make any changes to the generated C-files as they will
     be overwritten the next time <SPAN
CLASS="APPLICATION"
>lex</SPAN
>
     or <SPAN
CLASS="APPLICATION"
>yacc</SPAN
> is called.

     </P><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>       The mentioned transformations and compilations are normally done
       automatically using the <I
CLASS="FIRSTTERM"
>makefiles</I
>
       shipped with the <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
       source distribution.
      </P
></BLOCKQUOTE
></DIV
><P>
    </P
><P
>     A detailed description of <SPAN
CLASS="APPLICATION"
>yacc</SPAN
> or
     the grammar rules given in <TT
CLASS="FILENAME"
>gram.y</TT
> would be
     beyond the scope of this paper. There are many books and
     documents dealing with <SPAN
CLASS="APPLICATION"
>lex</SPAN
> and
     <SPAN
CLASS="APPLICATION"
>yacc</SPAN
>. You should be familiar with
     <SPAN
CLASS="APPLICATION"
>yacc</SPAN
> before you start to study the
     grammar given in <TT
CLASS="FILENAME"
>gram.y</TT
> otherwise you won't
     understand what happens there.
    </P
><P
>     For a better understanding of the data structures used in
     <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
     for the processing of a query we use an example to illustrate the
     changes made to these data structures in every stage.
     This example contains the following simple query that will be used in
     various descriptions and figures throughout the following
     sections. The query assumes that the tables given in
     <I
CLASS="CITETITLE"
>The Supplier Database</I
>
     
     have already been defined.

     <DIV
CLASS="EXAMPLE"
><A
NAME="SIMPLE-SELECT"
></A
><P
><B
>Example 2-1. A Simple Select</B
></P
><PRE
CLASS="PROGRAMLISTING"
>select s.sname, se.pno
    from supplier s, sells se
    where s.sno &#62; 2 and s.sno = se.sno;
      </PRE
></DIV
>
    </P
><P
>     Figure \ref{parsetree} shows the <I
CLASS="FIRSTTERM"
>parse tree</I
> built by the
     grammar rules and actions given in <TT
CLASS="FILENAME"
>gram.y</TT
> for the query
     given in  <A
HREF="parser-stage.html#SIMPLE-SELECT"
>Example 2-1</A
>
     (without the <I
CLASS="FIRSTTERM"
>operator tree</I
> for
     the <I
CLASS="FIRSTTERM"
>where clause</I
> which is shown in figure \ref{where_clause}
     because there was not enough space to show both data structures in one
     figure).
    </P
><P
>     The top node of the tree is a <TT
CLASS="LITERAL"
>SelectStmt</TT
> node. For every entry
     appearing in the <I
CLASS="FIRSTTERM"
>from clause</I
> of the SQL query a <TT
CLASS="LITERAL"
>RangeVar</TT
>
     node is created holding the name of the <I
CLASS="FIRSTTERM"
>alias</I
> and a pointer to a
     <TT
CLASS="LITERAL"
>RelExpr</TT
> node holding the name of the <I
CLASS="FIRSTTERM"
>relation</I
>. All
     <TT
CLASS="LITERAL"
>RangeVar</TT
> nodes are collected in a list which is attached to the field
     <TT
CLASS="LITERAL"
>fromClause</TT
> of the <TT
CLASS="LITERAL"
>SelectStmt</TT
> node.
    </P
><P
>     For every entry appearing in the <I
CLASS="FIRSTTERM"
>select list</I
> of the SQL query a
     <TT
CLASS="LITERAL"
>ResTarget</TT
> node is created holding a pointer to an <TT
CLASS="LITERAL"
>Attr</TT
>
     node. The <TT
CLASS="LITERAL"
>Attr</TT
> node holds the <I
CLASS="FIRSTTERM"
>relation name</I
> of the entry and
     a pointer to a <TT
CLASS="LITERAL"
>Value</TT
> node holding the name of the
     <I
CLASS="FIRSTTERM"
>attribute</I
>.
     All <TT
CLASS="LITERAL"
>ResTarget</TT
> nodes are collected to a list which is
     connected to the field <TT
CLASS="LITERAL"
>targetList</TT
> of the <TT
CLASS="LITERAL"
>SelectStmt</TT
> node.
    </P
><P
>     Figure \ref{where_clause} shows the operator tree built for the
     where clause of the SQL query given in
     <A
HREF="parser-stage.html#SIMPLE-SELECT"
>Example 2-1</A
>
     which is attached to the field
     <TT
CLASS="LITERAL"
>qual</TT
> of the <TT
CLASS="LITERAL"
>SelectStmt</TT
> node. The top node of the
     operator tree is an <TT
CLASS="LITERAL"
>A_Expr</TT
> node representing an <TT
CLASS="LITERAL"
>AND</TT
>
     operation. This node has two successors called <TT
CLASS="LITERAL"
>lexpr</TT
> and
     <TT
CLASS="LITERAL"
>rexpr</TT
> pointing to two <I
CLASS="FIRSTTERM"
>subtrees</I
>. The subtree attached to
     <TT
CLASS="LITERAL"
>lexpr</TT
> represents the qualification <TT
CLASS="LITERAL"
>s.sno &gt; 2</TT
> and the one
     attached to <TT
CLASS="LITERAL"
>rexpr</TT
> represents <TT
CLASS="LITERAL"
>s.sno = se.sno</TT
>. For every
     attribute an <TT
CLASS="LITERAL"
>Attr</TT
> node is created holding the name of the
     relation and a pointer to a <TT
CLASS="LITERAL"
>Value</TT
> node holding the name of the
     attribute. For the constant term appearing in the query a
     <TT
CLASS="LITERAL"
>Const</TT
> node is created holding the value.
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN52090"
>2.3.2. Transformation Process</A
></H2
><P
>     The <I
CLASS="FIRSTTERM"
>transformation process</I
> takes the tree handed back by
     the parser as input and steps recursively through it.  If
     a <TT
CLASS="LITERAL"
>SelectStmt</TT
> node is found, it is transformed
     to a <TT
CLASS="LITERAL"
>Query</TT
>
     node that will be the top most node of the new data structure. Figure
     \ref{transformed} shows the transformed data structure (the part
     for the transformed <I
CLASS="FIRSTTERM"
>where clause</I
> is given in figure
     \ref{transformed_where} because there was not enough space to show all
     parts in one figure).
    </P
><P
>     Now a check is made, if the <I
CLASS="FIRSTTERM"
>relation names</I
> in the
     <I
CLASS="FIRSTTERM"
>FROM clause</I
> are known to the system. For every relation name
     that is present in the <I
CLASS="FIRSTTERM"
>system catalogs</I
> a <SPAN
CLASS="ABBREV"
>RTE</SPAN
> node is
     created containing the relation name, the <I
CLASS="FIRSTTERM"
>alias name</I
> and
     the <I
CLASS="FIRSTTERM"
>relation id</I
>. From now on the relation ids are used to
     refer to the <I
CLASS="FIRSTTERM"
>relations</I
> given in the query. All <SPAN
CLASS="ABBREV"
>RTE</SPAN
> nodes
     are collected in the <I
CLASS="FIRSTTERM"
>range table entry list</I
> that is connected
     to the field <TT
CLASS="LITERAL"
>rtable</TT
> of the <TT
CLASS="LITERAL"
>Query</TT
> node. If a name of a
     relation that is not known to the system is detected in the query an
     error will be returned and the query processing will be aborted.
    </P
><P
>     Next it is checked if the <I
CLASS="FIRSTTERM"
>attribute names</I
> used are 
     contained in the relations given in the query. For every
     attribute} that is found a <SPAN
CLASS="ABBREV"
>TLE</SPAN
> node is created holding a pointer
     to a <TT
CLASS="LITERAL"
>Resdom</TT
> node (which holds the name of the column) and a
     pointer to a <TT
CLASS="LITERAL"
>VAR</TT
> node. There are two important numbers in the
     <TT
CLASS="LITERAL"
>VAR</TT
> node. The field <TT
CLASS="LITERAL"
>varno</TT
> gives the position of the
     relation containing the current attribute} in the range
     table entry list created above. The field <TT
CLASS="LITERAL"
>varattno</TT
> gives the
     position of the attribute within the relation. If the name
     of an attribute cannot be found an error will be returned and
     the query processing will be aborted.
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="connect-estab.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="rule-system.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>How Connections are Established</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="overview.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>The <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> Rule System</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>