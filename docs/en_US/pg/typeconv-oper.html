<HTML
><HEAD
><TITLE
>Operators</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.73
"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.3.3 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Type Conversion"
HREF="typeconv.html"><LINK
REL="PREVIOUS"
TITLE="Type Conversion"
HREF="typeconv.html"><LINK
REL="NEXT"
TITLE="Functions"
HREF="typeconv-func.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-05-24T21:33:34"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.3.3 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="typeconv.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 7. Type Conversion</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="typeconv-func.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TYPECONV-OPER"
>7.2. Operators</A
></H1
><P
>   The operand types of an operator invocation are resolved following
   the procedure below.  Note that this procedure is indirectly affected
   by the precedence of the involved operators.  See <A
HREF="sql-syntax.html#SQL-PRECEDENCE"
>Section 1.1.6</A
> for more information.
  </P
><DIV
CLASS="PROCEDURE"
><P
><B
>Operand Type Resolution</B
></P
><OL
TYPE="1"
><LI
><P
>Select the operators to be considered from the
<TT
CLASS="CLASSNAME"
>pg_operator</TT
> system catalog.  If an unqualified
operator name is used (the usual case), the operators
considered are those of the right name and argument count that are
visible in the current search path (see <A
HREF="ddl-schemas.html#DDL-SCHEMAS-PATH"
>Section 2.8.3</A
>).
If a qualified operator name was given, only operators in the specified
schema are considered.</P
><OL
CLASS="SUBSTEPS"
TYPE="a"
><LI
><P
>If the search path finds multiple operators of identical argument types,
only the one appearing earliest in the path is considered.  But operators of
different argument types are considered on an equal footing regardless of
search path position.</P
></LI
></OL
></LI
><LI
><P
>Check for an operator accepting exactly the input argument types.
If one exists (there can be only one exact match in the set of
operators considered), use it.</P
><OL
CLASS="SUBSTEPS"
TYPE="a"
><LI
><P
>If one argument of a binary operator is <TT
CLASS="TYPE"
>unknown</TT
> type,
then assume it is the same type as the other argument for this check.
Other cases involving <TT
CLASS="TYPE"
>unknown</TT
> will never find a match at
this step.</P
></LI
></OL
></LI
><LI
><P
>Look for the best match.</P
><OL
CLASS="SUBSTEPS"
TYPE="a"
><LI
><P
>Discard candidate operators for which the input types do not match
and cannot be coerced (using an implicit coercion function) to match.
<TT
CLASS="TYPE"
>unknown</TT
> literals are
assumed to be coercible to anything for this purpose.  If only one
candidate remains, use it; else continue to the next step.</P
></LI
><LI
><P
>Run through all candidates and keep those with the most exact matches
on input types.  Keep all candidates if none have any exact matches.
If only one candidate remains, use it; else continue to the next step.</P
></LI
><LI
><P
>Run through all candidates and keep those with the most exact or
binary-compatible matches on input types.  Keep all candidates if none have
any exact or binary-compatible matches.
If only one candidate remains, use it; else continue to the next step.</P
></LI
><LI
><P
>Run through all candidates and keep those that accept preferred types at
the most positions where type coercion will be required.
Keep all candidates if none accept preferred types.
If only one candidate remains, use it; else continue to the next step.</P
></LI
><LI
><P
>If any input arguments are <SPAN
CLASS="QUOTE"
>"unknown"</SPAN
>, check the type
categories accepted at those argument positions by the remaining
candidates.  At each position, select the "string" category if any
candidate accepts that category (this bias towards string is appropriate
since an unknown-type literal does look like a string). Otherwise, if
all the remaining candidates accept the same type category, select that
category; otherwise fail because the correct choice cannot be deduced
without more clues.  Also note whether any of the candidates accept a
preferred data type within the selected category. Now discard operator
candidates that do not accept the selected type category; furthermore,
if any candidate accepts a preferred type at a given argument position,
discard candidates that accept non-preferred types for that argument.</P
></LI
><LI
><P
>If only one candidate remains, use it.  If no candidate or more than one
candidate remains,
then fail.</P
></LI
></OL
></LI
></OL
></DIV
><H3
CLASS="BRIDGEHEAD"
><A
NAME="AEN10833">Examples</H3
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN10834"
></A
><P
><B
>Example 7-1. Exponentiation Operator Type Resolution</B
></P
><P
>There is only one exponentiation
operator defined in the catalog, and it takes arguments of type 
<TT
CLASS="TYPE"
>double precision</TT
>.
The scanner assigns an initial type of <TT
CLASS="TYPE"
>integer</TT
> to both arguments
of this query expression:
</P><PRE
CLASS="SCREEN"
>tgl=&#62; SELECT 2 ^ 3 AS "Exp";
 Exp
-----
   8
(1 row)</PRE
><P>

So the parser does a type conversion on both operands and the query
is equivalent to

</P><PRE
CLASS="SCREEN"
>tgl=&#62; SELECT CAST(2 AS double precision) ^ CAST(3 AS double precision) AS "Exp";
 Exp
-----
   8
(1 row)</PRE
><P>

or

</P><PRE
CLASS="SCREEN"
>tgl=&#62; SELECT 2.0 ^ 3.0 AS "Exp";
 Exp
-----
   8
(1 row)</PRE
><P>

</P><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>This last form has the least overhead, since no functions are called to do
implicit type conversion. This is not an issue for small queries, but may
have an impact on the performance of queries involving large tables.</P
></BLOCKQUOTE
></DIV
><P></P
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN10844"
></A
><P
><B
>Example 7-2. String Concatenation Operator Type Resolution</B
></P
><P
>A string-like syntax is used for working with string types as well as for
working with complex extended types.
Strings with unspecified type are matched with likely operator candidates.</P
><P
>An example with one unspecified argument:
</P><PRE
CLASS="SCREEN"
>tgl=&#62; SELECT text 'abc' || 'def' AS "Text and Unknown";
 Text and Unknown
------------------
 abcdef
(1 row)</PRE
><P></P
><P
>In this case the parser looks to see if there is an operator taking <TT
CLASS="TYPE"
>text</TT
>
for both arguments. Since there is, it assumes that the second argument should
be interpreted as of type <TT
CLASS="TYPE"
>text</TT
>.</P
><P
>Concatenation on unspecified types:
</P><PRE
CLASS="SCREEN"
>tgl=&#62; SELECT 'abc' || 'def' AS "Unspecified";
 Unspecified
-------------
 abcdef
(1 row)</PRE
><P></P
><P
>In this case there is no initial hint for which type to use, since no types
are specified in the query. So, the parser looks for all candidate operators
and finds that there are candidates accepting both string-category and
bit-string-category inputs.  Since string category is preferred when available,
that category is selected, and then the 
<SPAN
CLASS="QUOTE"
>"preferred type"</SPAN
> for strings, <TT
CLASS="TYPE"
>text</TT
>, is used as the specific
type to resolve the unknown literals to.</P
></DIV
><DIV
CLASS="EXAMPLE"
><A
NAME="AEN10857"
></A
><P
><B
>Example 7-3. Absolute-Value and Factorial Operator Type Resolution</B
></P
><P
>The <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> operator catalog has several
entries for the prefix operator <TT
CLASS="LITERAL"
>@</TT
>, all of which implement
absolute-value operations for various numeric data types.  One of these
entries is for type <TT
CLASS="TYPE"
>float8</TT
>, which is the preferred type in
the numeric category.  Therefore, <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>
will use that entry when faced with a non-numeric input:
</P><PRE
CLASS="SCREEN"
>tgl=&#62; select @ text '-4.5' as "abs";
 abs
-----
 4.5
(1 row)</PRE
><P>
Here the system has performed an implicit text-to-float8 conversion
before applying the chosen operator.  We can verify that float8 and
not some other type was used:
</P><PRE
CLASS="SCREEN"
>tgl=&#62; select @ text '-4.5e500' as "abs";
ERROR:  Input '-4.5e500' is out of range for float8</PRE
><P></P
><P
>On the other hand, the postfix operator <TT
CLASS="LITERAL"
>!</TT
> (factorial)
is defined only for integer data types, not for float8.  So, if we
try a similar case with <TT
CLASS="LITERAL"
>!</TT
>, we get:
</P><PRE
CLASS="SCREEN"
>tgl=&#62; select text '20' ! as "factorial";
ERROR:  Unable to identify a postfix operator '!' for type 'text'
        You may need to add parentheses or an explicit cast</PRE
><P>
This happens because the system can't decide which of the several
possible <TT
CLASS="LITERAL"
>!</TT
> operators should be preferred.  We can help
it out with an explicit cast:
</P><PRE
CLASS="SCREEN"
>tgl=&#62; select cast(text '20' as int8) ! as "factorial";
      factorial
---------------------
 2432902008176640000
(1 row)</PRE
><P></P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="typeconv.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="typeconv-func.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Type Conversion</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="typeconv.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Functions</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>