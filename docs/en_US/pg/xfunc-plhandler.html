<HTML
><HEAD
><TITLE
>Procedural Language Handlers</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.73
"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.3.3 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Extending SQL: Functions"
HREF="xfunc.html"><LINK
REL="PREVIOUS"
TITLE="Table Functions"
HREF="xfunc-tablefunctions.html"><LINK
REL="NEXT"
TITLE="Extending SQL: Types"
HREF="xtypes.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-05-24T21:33:34"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.3.3 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="xfunc-tablefunctions.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 9. Extending <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>: Functions</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="xtypes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XFUNC-PLHANDLER"
>9.8. Procedural Language Handlers</A
></H1
><P
>    All calls to functions that are written in a language other than
    the current <SPAN
CLASS="QUOTE"
>"version 1"</SPAN
> interface for compiled
    languages (this includes functions in user-defined procedural languages,
    functions written in SQL, and functions using the version 0 compiled
    language interface), go through a <I
CLASS="FIRSTTERM"
>call handler</I
>
    function for the specific language.  It is the responsibility of
    the call handler to execute the function in a meaningful way, such
    as by interpreting the supplied source text.  This section
    describes how a language call handler can be written.  This is not
    a common task, in fact, it has only been done a handful of times
    in the history of <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>, but the
    topic naturally belongs in this chapter, and the material might
    give some insight into the extensible nature of the
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> system.
   </P
><P
>    The call handler for a procedural language is a
    <SPAN
CLASS="QUOTE"
>"normal"</SPAN
> function, which must be written in a
    compiled language such as C and registered with
    <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> as taking no arguments and
    returning the <TT
CLASS="TYPE"
>language_handler</TT
> type.
    This special pseudo-type identifies the handler as a call handler
    and prevents it from being called directly in queries.
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>     In <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.1 and later, call
     handlers must adhere to the <SPAN
CLASS="QUOTE"
>"version 1"</SPAN
> function
     manager interface, not the old-style interface.
    </P
></BLOCKQUOTE
></DIV
><P
>    The call handler is called in the same way as any other function:
    It receives a pointer to a
    <TT
CLASS="STRUCTNAME"
>FunctionCallInfoData</TT
> <TT
CLASS="TYPE"
>struct</TT
> containing
    argument values and information about the called function, and it
    is expected to return a <TT
CLASS="TYPE"
>Datum</TT
> result (and possibly
    set the <TT
CLASS="STRUCTFIELD"
>isnull</TT
> field of the
    <TT
CLASS="STRUCTNAME"
>FunctionCallInfoData</TT
> structure, if it wishes
    to return an SQL NULL result).  The difference between a call
    handler and an ordinary callee function is that the
    <TT
CLASS="STRUCTFIELD"
>flinfo-&gt;fn_oid</TT
> field of the
    <TT
CLASS="STRUCTNAME"
>FunctionCallInfoData</TT
> structure will contain
    the OID of the actual function to be called, not of the call
    handler itself.  The call handler must use this field to determine
    which function to execute.  Also, the passed argument list has
    been set up according to the declaration of the target function,
    not of the call handler.
   </P
><P
>    It's up to the call handler to fetch the
    <TT
CLASS="CLASSNAME"
>pg_proc</TT
> entry and to analyze the argument
    and return types of the called procedure. The AS clause from the
    <TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
> of the procedure will be found
    in the <TT
CLASS="LITERAL"
>prosrc</TT
> attribute of the
    <TT
CLASS="CLASSNAME"
>pg_proc</TT
> table entry. This may be the source
    text in the procedural language itself (like for PL/Tcl), a
    path name to a file, or anything else that tells the call handler
    what to do in detail.
   </P
><P
>    Often, the same function is called many times per SQL statement.
    A call handler can avoid repeated lookups of information about the
    called function by using the
    <TT
CLASS="STRUCTFIELD"
>flinfo-&gt;fn_extra</TT
> field.  This will
    initially be NULL, but can be set by the call handler to point at
    information about the PL function.  On subsequent calls, if
    <TT
CLASS="STRUCTFIELD"
>flinfo-&gt;fn_extra</TT
> is already non-NULL
    then it can be used and the information lookup step skipped.  The
    call handler must be careful that
    <TT
CLASS="STRUCTFIELD"
>flinfo-&gt;fn_extra</TT
> is made to point at
    memory that will live at least until the end of the current query,
    since an <TT
CLASS="STRUCTNAME"
>FmgrInfo</TT
> data structure could be
    kept that long.  One way to do this is to allocate the extra data
    in the memory context specified by
    <TT
CLASS="STRUCTFIELD"
>flinfo-&gt;fn_mcxt</TT
>; such data will
    normally have the same lifespan as the
    <TT
CLASS="STRUCTNAME"
>FmgrInfo</TT
> itself.  But the handler could
    also choose to use a longer-lived context so that it can cache
    function definition information across queries.
   </P
><P
>    When a PL function is invoked as a trigger, no explicit arguments
    are passed, but the
    <TT
CLASS="STRUCTNAME"
>FunctionCallInfoData</TT
>'s
    <TT
CLASS="STRUCTFIELD"
>context</TT
> field points at a
    <TT
CLASS="STRUCTNAME"
>TriggerData</TT
> node, rather than being NULL
    as it is in a plain function call.  A language handler should
    provide mechanisms for PL functions to get at the trigger
    information.
   </P
><P
>    This is a template for a PL handler written in C:
</P><PRE
CLASS="PROGRAMLISTING"
>#include "postgres.h"
#include "executor/spi.h"
#include "commands/trigger.h"
#include "utils/elog.h"
#include "fmgr.h"
#include "access/heapam.h"
#include "utils/syscache.h"
#include "catalog/pg_proc.h"
#include "catalog/pg_type.h"

PG_FUNCTION_INFO_V1(plsample_call_handler);

Datum
plsample_call_handler(PG_FUNCTION_ARGS)
{
    Datum          retval;

    if (CALLED_AS_TRIGGER(fcinfo))
    {
        /*
         * Called as a trigger procedure
         */
        TriggerData    *trigdata = (TriggerData *) fcinfo-&#62;context;

        retval = ...
    }
    else {
        /*
         * Called as a function
         */

        retval = ...
    }

    return retval;
}</PRE
><P>
   </P
><P
>    Only a few thousand lines of code have to be added instead of the
    dots to complete the call handler.  See <A
HREF="xfunc-c.html"
>Section 9.5</A
>
    for information on how to compile it into a loadable module.
   </P
><P
>    The following commands then register the sample procedural
    language:
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION plsample_call_handler () RETURNS language_handler
    AS '/usr/local/pgsql/lib/plsample'
    LANGUAGE C;
CREATE LANGUAGE plsample
    HANDLER plsample_call_handler;</PRE
><P>
   </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xfunc-tablefunctions.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xtypes.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Table Functions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="xfunc.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Extending <SPAN
CLASS="ACRONYM"
>SQL</SPAN
>: Types</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>