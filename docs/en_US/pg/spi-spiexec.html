<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>SPI_exec</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 7.4beta2 Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Interface Functions"
HREF="spi.html#SPI-INTERFACE"><LINK
REL="PREVIOUS"
TITLE="SPI_finish"
HREF="spi-spifinish.html"><LINK
REL="NEXT"
TITLE="SPI_prepare"
HREF="spi-spiprepare.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
NAME="creation"
CONTENT="2003-08-27T02:55:32"></HEAD
><BODY
CLASS="REFENTRY"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>PostgreSQL 7.4beta2 Documentation</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="spi-spifinish.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="spi-spiprepare.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SPI-SPIEXEC"
></A
>SPI_exec</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN32479"
></A
><H2
>Name</H2
>SPI_exec&nbsp;--&nbsp;   Creates an execution plan (parser+planner+optimizer) and executes a query.<A
NAME="IX-SPI-SPIEXEC-1"
></A
><A
NAME="IX-SPI-SPIEXEC-2"
></A
></DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN32487"
></A
><H2
>Synopsis</H2
><PRE
CLASS="SYNOPSIS"
>SPI_exec(<VAR
CLASS="REPLACEABLE"
>query</VAR
>, <VAR
CLASS="REPLACEABLE"
>tcount</VAR
>)</PRE
><DIV
CLASS="REFSECT2"
><A
NAME="R2-SPI-SPIEXEC-1"
></A
><H3
>Inputs</H3
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>const char * <VAR
CLASS="REPLACEABLE"
>query</VAR
></DT
><DD
><P
>String containing query plan</P
></DD
><DT
>int <VAR
CLASS="REPLACEABLE"
>tcount</VAR
></DT
><DD
><P
>Maximum number of tuples to return</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="R2-SPI-SPIEXEC-2"
></A
><H3
>Outputs</H3
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>int</DT
><DD
><P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_UNCONNECTED</SPAN
> if called from an un-connected procedure</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_ARGUMENT</SPAN
> if query is NULL or <VAR
CLASS="REPLACEABLE"
>tcount</VAR
> &#60; 0.</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_UNCONNECTED</SPAN
> if procedure is unconnected.</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_COPY</SPAN
> if COPY TO/FROM stdin.</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_CURSOR</SPAN
> if DECLARE/CLOSE CURSOR, FETCH.</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_TRANSACTION</SPAN
> if BEGIN/ABORT/END.</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_OPUNKNOWN</SPAN
> if type of query is unknown (this shouldn't occur).</TD
></TR
></TBODY
></TABLE
><P
></P
></P
><P
>   If execution of your query was successful then one of the following
   (non-negative) values will be returned:
<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_OK_UTILITY</SPAN
> if some utility (e.g. CREATE TABLE ...) was executed</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_OK_SELECT</SPAN
> if SELECT (but not SELECT ... INTO!) was executed</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_OK_SELINTO</SPAN
> if SELECT ... INTO was executed</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_OK_INSERT</SPAN
> if INSERT (or INSERT ... SELECT) was executed</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_OK_DELETE</SPAN
> if DELETE was executed</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_OK_UPDATE</SPAN
> if UPDATE was executed</TD
></TR
></TBODY
></TABLE
><P
></P
></P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="R1-SPI-SPIEXEC-1"
></A
><H2
>Description</H2
><P
><CODE
CLASS="FUNCTION"
>SPI_exec</CODE
> creates an execution plan (parser+planner+optimizer)
 and executes the query for <VAR
CLASS="REPLACEABLE"
>tcount</VAR
> tuples.&#13;</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="R1-SPI-SPIEXEC-2"
></A
><H2
>Usage</H2
><P
>  This should only be called from a connected procedure.
   If <VAR
CLASS="REPLACEABLE"
>tcount</VAR
> is zero then it executes the query for all tuples returned by the
   query scan. Using <VAR
CLASS="REPLACEABLE"
>tcount</VAR
> &#62; 0 you may restrict the number of tuples for
   which the query will be executed (much like a LIMIT clause). For example,

</P><PRE
CLASS="PROGRAMLISTING"
>SPI_exec ("INSERT INTO tab SELECT * FROM tab", 5);</PRE
><P>

will allow at most 5 tuples to be inserted into table.

   If execution of your query was successful then a non-negative value will be returned.

</P><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>You may pass multiple queries in one string or query string may be
   re-written by RULEs. <CODE
CLASS="FUNCTION"
>SPI_exec</CODE
> returns the result for the last query
   executed.</P
></BLOCKQUOTE
></DIV
><P></P
><P
>   The actual number of tuples for which the (last) query was executed is
   returned in the global variable SPI_processed (if not <SPAN
CLASS="RETURNVALUE"
>SPI_OK_UTILITY</SPAN
>).

   If <SPAN
CLASS="RETURNVALUE"
>SPI_OK_SELECT</SPAN
> is returned then you may use global
   pointer SPITupleTable *SPI_tuptable to access the result tuples.</P
><P
>   <CODE
CLASS="FUNCTION"
>SPI_exec</CODE
> may return one of the following (negative) values:
<P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_ARGUMENT</SPAN
> if query is NULL or <VAR
CLASS="REPLACEABLE"
>tcount</VAR
> &#60; 0.</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_UNCONNECTED</SPAN
> if procedure is unconnected.</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_COPY</SPAN
> if COPY TO/FROM stdin.</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_CURSOR</SPAN
> if DECLARE/CLOSE CURSOR, FETCH.</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_TRANSACTION</SPAN
> if BEGIN/ABORT/END.</TD
></TR
><TR
><TD
>   <SPAN
CLASS="RETURNVALUE"
>SPI_ERROR_OPUNKNOWN</SPAN
> if type of query is unknown (this shouldn't occur).</TD
></TR
></TBODY
></TABLE
><P
></P
>&#13;</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="R1-SPI-SPIEXEC-4"
></A
><H2
>Structures</H2
><P
>   If <SPAN
CLASS="RETURNVALUE"
>SPI_OK_SELECT</SPAN
> is returned then you may use the global
   pointer SPITupleTable *SPI_tuptable to access the selected tuples.</P
><P
>   Structure SPITupleTable is defined in spi.h:
</P><PRE
CLASS="PROGRAMLISTING"
>   typedef struct
   {
       MemoryContext tuptabcxt;    /* memory context of result table */
       uint32      alloced;        /* # of alloced vals */
       uint32      free;           /* # of free vals */
       TupleDesc   tupdesc;        /* tuple descriptor */
       HeapTuple  *vals;           /* tuples */
   } SPITupleTable;</PRE
><P></P
><P
>   <TT
CLASS="STRUCTFIELD"
>vals</TT
> is an array of pointers to tuples (the number of useful entries
   is given by SPI_processed). <TT
CLASS="STRUCTFIELD"
>tupdesc</TT
> is
   a tuple descriptor which you may pass to SPI functions dealing with
   tuples.  <TT
CLASS="STRUCTFIELD"
>tuptabcxt</TT
>, <TT
CLASS="STRUCTFIELD"
>alloced</TT
>, and <TT
CLASS="STRUCTFIELD"
>free</TT
> are internal fields not intended
   for use by SPI callers.</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>   Functions <CODE
CLASS="FUNCTION"
>SPI_exec</CODE
>, <CODE
CLASS="FUNCTION"
>SPI_execp</CODE
> and
   <CODE
CLASS="FUNCTION"
>SPI_prepare</CODE
> change both SPI_processed and SPI_tuptable
   (just the pointer, not the contents of the structure).
   Save these two global variables into local procedure variables if you need
   to access the result of one <CODE
CLASS="FUNCTION"
>SPI_exec</CODE
> or
   <CODE
CLASS="FUNCTION"
>SPI_execp</CODE
> across later calls.</P
></BLOCKQUOTE
></DIV
><P
>   <CODE
CLASS="FUNCTION"
>SPI_finish</CODE
> frees all SPITupleTables allocated during
   the current procedure.  You can free a particular result table earlier,
   if you are done with it, by calling <CODE
CLASS="FUNCTION"
>SPI_freetuptable</CODE
>.</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="spi-spifinish.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="spi-spiprepare.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>SPI_finish</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="spi.html#SPI-INTERFACE"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>SPI_prepare</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>